{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/prabishdangi/Desktop/Personal/untitled%20folder%203/quotation-restorefine/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n  })\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n\nexport default prisma\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,sMAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEF,wCAA2C,gBAAgB,MAAM,GAAG;uCAErD"}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["file:///Users/prabishdangi/Desktop/Personal/untitled%20folder%203/quotation-restorefine/src/lib/session.ts"],"sourcesContent":["import { randomBytes } from 'crypto'\nimport prisma from './prisma'\n\nconst SESSION_EXPIRY_DAYS = 30\n\n/**\n * Generate a cryptographically secure random session token\n * @returns 64-character hexadecimal token\n */\nexport function generateSessionToken(): string {\n  return randomBytes(32).toString('hex')\n}\n\n/**\n * Create a new session for a user\n * @param userId - User ID to create session for\n * @returns Created session object with token\n */\nexport async function createSession(userId: string) {\n  const token = generateSessionToken()\n  const expiresAt = new Date()\n  expiresAt.setDate(expiresAt.getDate() + SESSION_EXPIRY_DAYS)\n\n  const session = await prisma.session.create({\n    data: {\n      userId,\n      token,\n      expiresAt,\n    },\n    include: {\n      user: {\n        select: {\n          id: true,\n          email: true,\n          name: true,\n          createdAt: true,\n          updatedAt: true,\n        },\n      },\n    },\n  })\n\n  return session\n}\n\n/**\n * Validate a session token and return the session with user if valid\n * @param token - Session token to validate\n * @returns Session with user if valid, null otherwise\n */\nexport async function validateSession(token: string) {\n  const session = await prisma.session.findUnique({\n    where: { token },\n    include: {\n      user: {\n        select: {\n          id: true,\n          email: true,\n          name: true,\n          createdAt: true,\n          updatedAt: true,\n        },\n      },\n    },\n  })\n\n  if (!session) {\n    return null\n  }\n\n  // Check if session has expired\n  if (session.expiresAt < new Date()) {\n    // Delete expired session\n    await prisma.session.delete({\n      where: { id: session.id },\n    })\n    return null\n  }\n\n  return session\n}\n\n/**\n * Delete a session (for logout)\n * @param token - Session token to delete\n */\nexport async function deleteSession(token: string) {\n  await prisma.session.delete({\n    where: { token },\n  })\n}\n\n/**\n * Delete all sessions for a user (for password reset)\n * @param userId - User ID to delete all sessions for\n */\nexport async function deleteAllUserSessions(userId: string) {\n  await prisma.session.deleteMany({\n    where: { userId },\n  })\n}"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;;;AAEA,MAAM,sBAAsB;AAMrB,SAAS;IACd,OAAO,IAAA,oHAAW,EAAC,IAAI,QAAQ,CAAC;AAClC;AAOO,eAAe,cAAc,MAAc;IAChD,MAAM,QAAQ;IACd,MAAM,YAAY,IAAI;IACtB,UAAU,OAAO,CAAC,UAAU,OAAO,KAAK;IAExC,MAAM,UAAU,MAAM,iIAAM,CAAC,OAAO,CAAC,MAAM,CAAC;QAC1C,MAAM;YACJ;YACA;YACA;QACF;QACA,SAAS;YACP,MAAM;gBACJ,QAAQ;oBACN,IAAI;oBACJ,OAAO;oBACP,MAAM;oBACN,WAAW;oBACX,WAAW;gBACb;YACF;QACF;IACF;IAEA,OAAO;AACT;AAOO,eAAe,gBAAgB,KAAa;IACjD,MAAM,UAAU,MAAM,iIAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC9C,OAAO;YAAE;QAAM;QACf,SAAS;YACP,MAAM;gBACJ,QAAQ;oBACN,IAAI;oBACJ,OAAO;oBACP,MAAM;oBACN,WAAW;oBACX,WAAW;gBACb;YACF;QACF;IACF;IAEA,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,+BAA+B;IAC/B,IAAI,QAAQ,SAAS,GAAG,IAAI,QAAQ;QAClC,yBAAyB;QACzB,MAAM,iIAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAC1B,OAAO;gBAAE,IAAI,QAAQ,EAAE;YAAC;QAC1B;QACA,OAAO;IACT;IAEA,OAAO;AACT;AAMO,eAAe,cAAc,KAAa;IAC/C,MAAM,iIAAM,CAAC,OAAO,CAAC,MAAM,CAAC;QAC1B,OAAO;YAAE;QAAM;IACjB;AACF;AAMO,eAAe,sBAAsB,MAAc;IACxD,MAAM,iIAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC9B,OAAO;YAAE;QAAO;IAClB;AACF"}},
    {"offset": {"line": 168, "column": 0}, "map": {"version":3,"sources":["file:///Users/prabishdangi/Desktop/Personal/untitled%20folder%203/quotation-restorefine/src/lib/auth.ts"],"sourcesContent":["import { cookies } from 'next/headers'\nimport { validateSession } from './session'\n\nconst COOKIE_NAME = process.env.COOKIE_NAME || 'auth_session'\n\n/**\n * Get the authenticated user from the request\n * @returns User object if authenticated, null otherwise\n */\nexport async function getAuthUser() {\n  const cookieStore = await cookies()\n  const sessionToken = cookieStore.get(COOKIE_NAME)?.value\n\n  if (!sessionToken) {\n    return null\n  }\n\n  const session = await validateSession(sessionToken)\n\n  if (!session) {\n    return null\n  }\n\n  return session.user\n}\n\n/**\n * Set the session cookie\n * @param token - Session token to set in cookie\n */\nexport async function setSessionCookie(token: string) {\n  const cookieStore = await cookies()\n  const expiresAt = new Date()\n  expiresAt.setDate(expiresAt.getDate() + 30) // 30 days\n\n  cookieStore.set(COOKIE_NAME, token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax',\n    expires: expiresAt,\n    path: '/',\n  })\n}\n\n/**\n * Clear the session cookie (for logout)\n */\nexport async function clearSessionCookie() {\n  const cookieStore = await cookies()\n  cookieStore.delete(COOKIE_NAME)\n}"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW,IAAI;AAMxC,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,eAAe,YAAY,GAAG,CAAC,cAAc;IAEnD,IAAI,CAAC,cAAc;QACjB,OAAO;IACT;IAEA,MAAM,UAAU,MAAM,IAAA,0IAAe,EAAC;IAEtC,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,OAAO,QAAQ,IAAI;AACrB;AAMO,eAAe,iBAAiB,KAAa;IAClD,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,YAAY,IAAI;IACtB,UAAU,OAAO,CAAC,UAAU,OAAO,KAAK,KAAI,UAAU;IAEtD,YAAY,GAAG,CAAC,aAAa,OAAO;QAClC,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,SAAS;QACT,MAAM;IACR;AACF;AAKO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,YAAY,MAAM,CAAC;AACrB"}},
    {"offset": {"line": 213, "column": 0}, "map": {"version":3,"sources":["file:///Users/prabishdangi/Desktop/Personal/untitled%20folder%203/quotation-restorefine/src/app/api/quotes/%5Bid%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport prisma from '@/lib/prisma'\nimport { getAuthUser } from '@/lib/auth'\n\n// GET /api/quotes/[id] - Get a specific quote (PUBLIC - no auth required for sharing)\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id } = await params\n\n    const quote = await prisma.quote.findUnique({\n      where: { id },\n    })\n\n    if (!quote) {\n      return NextResponse.json({ error: 'Quote not found' }, { status: 404 })\n    }\n\n    // Public access - anyone with the link can view the quote\n    return NextResponse.json({ quote })\n  } catch (error) {\n    console.error('Get quote error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n// PUT /api/quotes/[id] - Update a specific quote\nexport async function PUT(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const user = await getAuthUser()\n\n    if (!user) {\n      return NextResponse.json(\n        { error: 'Not authenticated' },\n        { status: 401 }\n      )\n    }\n\n    const { id } = await params\n    const body = await request.json()\n\n    // Check if quote exists and user owns it\n    const existingQuote = await prisma.quote.findUnique({\n      where: { id },\n    })\n\n    if (!existingQuote) {\n      return NextResponse.json({ error: 'Quote not found' }, { status: 404 })\n    }\n\n    if (existingQuote.userId !== user.id) {\n      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })\n    }\n\n    // Update quote\n    const quote = await prisma.quote.update({\n      where: { id },\n      data: {\n        clientName: body.clientName,\n        clientLogo: body.clientLogo ?? undefined,\n        packageName: body.packageName,\n        subtitle: body.subtitle,\n        videoCount: body.videoCount,\n        photoCount: body.photoCount,\n        showVideos: body.showVideos,\n        showPhotos: body.showPhotos,\n        platforms: body.platforms,\n        addOns: body.addOns,\n        price: body.price,\n        ctaTitle: body.ctaTitle,\n        ctaText: body.ctaText,\n        ctaHighlight: body.ctaHighlight,\n        ctaHighlightColor: body.ctaHighlightColor,\n        ctaHighlightUnderline: body.ctaHighlightUnderline,\n        ctaFooter: body.ctaFooter,\n      },\n    })\n\n    return NextResponse.json({\n      quote,\n      message: 'Quote updated successfully',\n    })\n  } catch (error) {\n    console.error('Update quote error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n// DELETE /api/quotes/[id] - Delete a specific quote\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const user = await getAuthUser()\n\n    if (!user) {\n      return NextResponse.json(\n        { error: 'Not authenticated' },\n        { status: 401 }\n      )\n    }\n\n    const { id } = await params\n\n    // Check if quote exists and user owns it\n    const existingQuote = await prisma.quote.findUnique({\n      where: { id },\n    })\n\n    if (!existingQuote) {\n      return NextResponse.json({ error: 'Quote not found' }, { status: 404 })\n    }\n\n    if (existingQuote.userId !== user.id) {\n      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })\n    }\n\n    // Delete quote\n    await prisma.quote.delete({\n      where: { id },\n    })\n\n    return NextResponse.json({\n      message: 'Quote deleted successfully',\n    })\n  } catch (error) {\n    console.error('Delete quote error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":"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"}}]
}